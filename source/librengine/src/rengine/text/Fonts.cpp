// __!!rengine_copyright!!__ //

#include <rengine/text/Fonts.h>

#include <rengine/outputstream/OutputStream.h>
#include <rengine/CoreEngine.h>
#include <rengine/RenderEngine.h> // opengl compliant textures?

#include <map>

namespace rengine
{
	//
	// Console
	//
	ConsoleFont::ConsoleFont()
	{
		name_ = "Console 8x15 Font";
	}

	ConsoleFont::~ConsoleFont()
	{
	}

	Bool ConsoleFont::load()
	{
		static Uint const width = 8;
		static Uint const height = 15;
		static Uint const ascent = 12;

		static Uchar const start_char = ' ';
		static Uchar const end_char = '~';
		static Uchar const char_data[95][15] = {
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x36, 0x36, 0x7f, 0x36, 0x36, 0x36, 0x7f, 0x36, 0x36, 0x00, 0x00, 0x00},
			{0x00, 0x08, 0x08, 0x3e, 0x6b, 0x68, 0x68, 0x3e, 0x0b, 0x0b, 0x6b, 0x3e, 0x08, 0x08, 0x00},
			{0x00, 0x00, 0x70, 0xd8, 0xda, 0x76, 0x0c, 0x18, 0x30, 0x6e, 0x5b, 0x1b, 0x0e, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x6c, 0xc7, 0xc6, 0x6e, 0x3b, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x00},
			{0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x1c, 0x7f, 0x1c, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x1c, 0x36, 0x63, 0x6b, 0x6b, 0x6b, 0x63, 0x36, 0x1c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3f, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x06, 0x0e, 0x1e, 0x36, 0x66, 0x66, 0x7f, 0x06, 0x06, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0x60, 0x60, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x1c, 0x30, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x06, 0x0c, 0x38, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0xc3, 0xc3, 0xcf, 0xdb, 0xdb, 0xcf, 0xc0, 0x7f, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0x60, 0x60, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0x60, 0x60, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x6e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x63, 0x77, 0x7f, 0x6b, 0x6b, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x63, 0x63, 0x73, 0x7b, 0x6f, 0x67, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x0c, 0x06, 0x00},
			{0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x63, 0x6b, 0x6b, 0x6b, 0x3e, 0x36, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x7e, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x60, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00},
			{0x00, 0x00, 0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x00, 0x00},
			{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00},
			{0x00, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
			{0x00, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x7e, 0x60, 0x60, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x1c, 0x30, 0x30, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x06, 0x7c},
			{0x00, 0x00, 0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x18, 0x18, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x0c, 0x0c, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x78},
			{0x00, 0x00, 0x00, 0x60, 0x60, 0x66, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x63, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x06, 0x06},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x60, 0x60, 0x3c, 0x06, 0x06, 0x7c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x30, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1c, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x6b, 0x6b, 0x3e, 0x36, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x0c, 0x78},
			{0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00, 0x00, 0x00},
			{0x00, 0x00, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x30, 0x18, 0x18, 0x18, 0x18, 0x0c, 0x00, 0x00},
			{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00},
			{0x00, 0x00, 0x30, 0x18, 0x18, 0x18, 0x18, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00},
			{0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
		};

		Bool state = true;

		setResolution(Resolution(96, 96));

		BitmapBuilder map_builder(height, margin());

		for (Uchar i = start_char; i <= end_char; ++i)
		{
			BitmapBuilder::CharData element;
			element.glyph = new Glyph();
			element.glyph->setCode(i);
			element.glyph->setDimension(Glyph::Dimension(width, height));

			element.glyph->setAdvance(Real(width));
			element.glyph->setBearingX(0.0f);
			element.glyph->setBearingY(Real(ascent));

			element.data = new Uchar[height];
			element.empty = true;

			for (Uchar line = 0; line != height; ++line)
			{
				element.data[line] = char_data[i - start_char][line];
				element.empty &= (char_data[i - start_char][line] == 0);
			}

			map_builder.addChar(element);
		}

		texture_ = map_builder.buildTexture();

		for (BitmapBuilder::CharTable::iterator line = map_builder.charTable().begin(); line != map_builder.charTable().end(); ++line)
		{
			for (BitmapBuilder::CharVector::iterator current_char = line->begin(); current_char != line->end(); ++current_char)
			{
				addGlyph(current_char->glyph->code(), current_char->glyph);
			}
		}

		return state;
	}

	//
	// CharMap BitmapBuilder
	//

	BitmapBuilder::CharData::CharData() :
		data(0), empty(true)
	{
	}

	BitmapBuilder::BitmapBuilder(Uint height, Font::Margin const glyph_margin) :
		font_height(height), margin(glyph_margin), image_channels(1)
	{
		texture_size = 0;
		expand(64);
	}

	BitmapBuilder::~BitmapBuilder()
	{
		while (!table.empty())
		{
			CharVector char_vector = table.back();
			table.pop_back();

			while (!char_vector.empty())
			{
				CharData element = char_vector.back();
				char_vector.pop_back();
				delete[](element.data);
			}
		}
	}

	void BitmapBuilder::setTargetImageChannels(Uint const channels)
	{
		image_channels = channels;
	}

	void BitmapBuilder::expand(Uint next_size)
	{
		Uint margin_y = Uint(margin.y());
		Uint margin_x = Uint(margin.x());

		// take in account bottom margin
		Uint size = texture_size > margin_y ? texture_size - margin_y : texture_size;

		// take in account top margin
		Uint lines_available = size / (font_height + margin_y);

		for (Uint i = 0; i != lines_available; ++i)
		{
			free_pixels[i] += next_size - texture_size;
		}

		// take in account bottom margin
		size = next_size > margin_y ? next_size - margin_y : next_size;

		// take in account top margin
		lines_available = size / (font_height + margin_y);

		while (table.size() < lines_available)
		{
			table.push_back(CharVector());
			free_pixels.push_back(next_size - margin_x); // add the right margin
		}

		texture_size = next_size;

	//	std::cout << "Expand to texture_size : " << texture_size << " lines_available " << lines_available << std::endl;
	}

	Uint BitmapBuilder::biggestFreeSlot(Uint& index)
	{
		Uint free_size = 0;
		index = 0;

		for (Uint i = 0; i != Uint (free_pixels.size()); ++i)
		{
			if (free_pixels[i] > free_size)
			{
				free_size = free_pixels[i];
				index = i;
			}
		}

		return free_size;
	}

	void BitmapBuilder::addChar(BitmapBuilder::CharData const& new_char)
	{
		Uint const max_texture_size = 2048;

		Uint line = 0;
		Uint free_space = biggestFreeSlot(line);
		Uint margin_x = Uint(margin.x());

		Uint width = new_char.glyph->dimension().x() + margin_x;

		//
		// Check if we need to expand
		//
		if (width > free_space)
		{
			if ( (texture_size << 1) > max_texture_size )
			{
				CoreEngine::instance()->log() << "Warning font texture size is above " <<  max_texture_size << "px. Discarding characters." << std::endl;
				return;
			}

			expand(texture_size << 1);
			free_space = biggestFreeSlot(line);
		}

		if (width <= free_space)
		{
			table[line].push_back(new_char);
			free_pixels[line] -= width;
			//	std::cout << "added to " << line << " free_ " <<  free_pixels[line] << std::endl;
		}
		else
		{
			CoreEngine::instance()->log() << "Warning font Char " << new_char.glyph->code() << " does not fit on the font bitmap. Discarding." << std::endl;
			return;
		}
	}

	SharedPointer<Texture2D> BitmapBuilder::buildTexture()
	{

		Uint margin_y = Uint(margin.y());
		Uint margin_x = Uint(margin.x());

		SharedPointer<Image> image = new Image();

		image->createImage(texture_size, texture_size, image_channels);
		image->zeroImage();

		Uint y = margin_y;
		for (CharTable::iterator line = table.begin(); line != table.end(); ++line)
		{
			Uint x = margin_x;
			for (CharVector::iterator current_char = line->begin(); current_char != line->end(); ++current_char)
			{
				rasterChar(x, y, *current_char, image);
				Font::Glyph::TextureCoords texture_coordinates(
						Real(x) / Real(texture_size), 1.0f - (Real(y + font_height) / Real(texture_size)) );
				current_char->glyph->setTextureCoords(texture_coordinates);

				x += current_char->glyph->dimension().x() + margin_x;
			}
			y += font_height + margin_y;
		}

		SharedPointer<Texture2D> texture = new Texture2D();
		image->makeOpenGlCompliant(true, !CoreEngine::instance()->renderEngine().supportsNonPowerOfTwoTextures());
		texture->setImage(image);

		return texture;
	}

	BitmapBuilder::CharTable& BitmapBuilder::charTable()
	{
		return table;
	}

	void BitmapBuilder::rasterChar(Uint x, Uint y, CharData current, SharedPointer<Image> image)
	{
		typedef Uchar uint8;

		uint8 const width = uint8( current.glyph->dimension().x() );
		uint8 const height = uint8( current.glyph->dimension().y() );
		uint8 const bytes_per_line = ((width - 1) >> 3) + 1;

		uint8 const set = 255;
		uint8 const notset = 0;

		uint8 const image_channels = image->getColorChannels();

		for (uint8 column = 0; column != bytes_per_line; ++column)
		{
			for (uint8 line = 0; line != height; ++line)
			{
				uint8 byte = current.data[column + line * bytes_per_line];
				Uchar* pixel = image->rawPixel(x + column * 8, y + line);


				// cycle all byte bits
				for (uint8 bit = 0; bit != 8; ++bit)
				{
					// check if this bit is used
					if (column * 8 + bit < width)
					{
						// copy data to all target image channels
						for (uint8 channel = 0; channel != image_channels; ++channel)
						{
							(*pixel++) = (byte & (1 << (7 - bit) )) ? set : notset;
						}
					}
				}
//				if (column * 8 + 0 < width) { (*pixel++) = (byte & 128) ? set : notset; }
//				if (column * 8 + 1 < width) { (*pixel++) = (byte &  64) ? set : notset; }
//				if (column * 8 + 2 < width) { (*pixel++) = (byte &  32) ? set : notset; }
//				if (column * 8 + 3 < width) { (*pixel++) = (byte &  16) ? set : notset; }
//				if (column * 8 + 4 < width) { (*pixel++) = (byte &   8) ? set : notset; }
//				if (column * 8 + 5 < width) { (*pixel++) = (byte &   4) ? set : notset; }
//				if (column * 8 + 6 < width) { (*pixel++) = (byte &   2) ? set : notset; }
//				if (column * 8 + 7 < width) { (*pixel++) = (byte &   1) ? set : notset; }
			}
		}


	}

} // namespace rengine
